<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite_beam</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Directional stuff based on which way boss is facing
beam_direction = object_murray_boss.jump_direction
if (beam_direction == 1) {
    boundary_x = object_boss_room_boundary_r.x
} else {boundary_x = object_boss_room_boundary_l.x}

player_x_pos = 0
player_y_pos = 0

prev_speed = speed
prev_direction = direction
rebounded = false
rebounds = 0
moved_past_player = false
keep_on_path = false
homing_on_player = false
power_level = 0

beam_part_speed = speed
beam_part_dir = direction - 180
beam_freeze_timer = -1

spawn_timer = 30
power_up_part_timer = 0

beam_impact = part_system_create()
part_system_depth(beam_impact, 0)

beam_absorb_sys = part_system_create()
part_system_depth(beam_impact, 0)

// Particles

// Beam trail
beam_impact_part = part_type_create()
part_type_shape(beam_impact_part, pt_shape_sphere)
part_type_orientation(beam_impact_part, 0, 0, 0, 0, 1)
part_type_size(beam_impact_part, 0.3, 0.5, 0, 0)
part_type_speed(beam_impact_part, beam_part_speed, beam_part_speed, 0, 0)
part_type_direction(beam_impact_part, beam_part_dir, beam_part_dir, 0, 0)
part_type_life(beam_impact_part, 12, 12)
part_type_alpha3(beam_impact_part, 1, 0.9, 0.1)
part_type_colour1(beam_impact_part, c_orange)

// Beam_absorb
beam_absorb_part = part_type_create()
part_type_shape(beam_absorb_part, pt_shape_ring)
part_type_orientation(beam_absorb_part, 0, 0, 0, 0, 1)
part_type_size(beam_absorb_part, 0.3, 0.3, 0, 0)
part_type_speed(beam_absorb_part, beam_part_speed, beam_part_speed, 0, 0)
part_type_direction(beam_absorb_part, beam_part_dir, beam_part_dir, 0, 0)
part_type_life(beam_absorb_part, 9, 9)
part_type_alpha3(beam_absorb_part, 1, 0.5, 0.1)
part_type_colour1(beam_absorb_part, c_white)

beam_impact_part_emitter = part_emitter_create(beam_impact)
beam_absorb_part_emitter = part_emitter_create(beam_absorb_sys)
part_emitter_region(beam_impact, beam_impact_part_emitter, x, x, y, y, ps_shape_ellipse, ps_distr_linear)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>part_emitter_region(beam_impact, beam_impact_part_emitter, x, x, y, y, ps_shape_ellipse, ps_distr_linear)
part_emitter_burst(beam_impact, beam_impact_part_emitter, beam_impact_part, 1)

image_angle = direction

if (shield_beam != -1) {
    if (shield_beam != 1) {
        part_type_shape(beam_impact_part, pt_shape_sphere)
        shield_beam = -1
    } else {
        part_type_shape(beam_impact_part, pt_shape_snow)
        shield_beam = -1    
    }
}

// CURVE
// SIGMOID FUNCTION
// Y = 1 / 1 + e^-x
// derivative = y * (1 - y)

// y = x^2 (inverse y for game maker)
// find x
// start of path x = -4
// 16, 9, 4, 1, 0, 1, 4, etc.
// dy/dx = -2x
// start of path = 8
// gradient = 8x
// sin = opp/hyp
// cos = adj/hyp
// tan = adj/opp
// choose two points
// y = 8 * 0
// y = 8 * 1
// (0,0) -&gt; (8,1)
// atan2(8,1)

// S shaped backstab

if (instance_exists(object_player)) {
    player_x_pos = object_player.x
    player_y_pos = object_player.y
}

if (beam_type == 1) {
    if (distance_to_point(player_x_pos, player_y_pos) &lt;= 45 &amp;&amp; ((beam_direction * x) &gt; (beam_direction * (object_murray_boss.start_pos_x + (beam_direction * 300))))) || keep_on_path {
        keep_on_path = true
    // Else follow sigmoid function curve
    } else if (((beam_direction * x) &lt; (beam_direction * (player_x_pos + (beam_direction * 90)))) &amp;&amp; !moved_past_player) &amp;&amp; (distance_to_point(boundary_x, y) &gt; 40) {
        new_x = x - (object_murray_boss.start_pos_x + (beam_direction * 250))
        new_y = 20 / (1 + exp(-0.1 * new_x))
        gradient = beam_direction * ((new_y / 20) * (20 - new_y))
        new_angle = arctan2(gradient,1) * (180/pi)
        if (beam_direction == 1) {
            direction = new_angle
        } else {
            direction = new_angle + 180
        }
        speed = 6
    } else if (y &lt; (player_y_pos - 50)) {
        moved_past_player = true
        direction = point_direction(x,y,x,player_y_pos - 50);
    } else {
        direction = point_direction(x,y,player_x_pos,player_y_pos);   
    }
// Homing curve
} else if (beam_type == 2) { 
    if distance_to_point(player_x_pos, player_y_pos) &lt;= 60 || keep_on_path {
        keep_on_path = true
    } else if ((beam_direction * x) &lt; (beam_direction * player_x_pos)) {
        new_x = x - (player_x_pos - ((player_x_pos - object_murray_boss.x)/2))
        //if new_x == 0 {
        //    new_x = 1
        //}
        gradient = -0.004 * new_x
        new_angle = arctan2(gradient,1) * (180/pi)
        if (beam_direction == 1) {
            direction = new_angle
        } else {
            direction = new_angle + 180
        }
        //show_message(direction)
        speed = 6
    }
// Death from above
} else if (beam_type == 3) {
    beam_beyond_halfway = ((beam_direction * x) &gt; (beam_direction * (object_boss_room_boundary_r.x - ((object_boss_room_boundary_r.x - object_boss_room_boundary_l.x)/2))))
    if ((distance_to_point(player_x_pos, player_y_pos) &lt;= 60) &amp;&amp; beam_beyond_halfway) || keep_on_path {
        keep_on_path = true
    } else if !beam_beyond_halfway &amp;&amp; !homing_on_player {
        if (beam_direction == 1) {
            direction = 30
        } else {
            direction = 150
        }
        //show_message(direction)
        speed = 6
    } else {   
        homing_on_player = true
        direction = point_direction(x,y,player_x_pos,player_y_pos);       
    }
// Straight forward from boss
} else if (beam_type &gt; -1) {
    speed = 6
    direction = 0
    if (beam_direction == 1) {
        direction = 0
    } else {
        direction = 180
    }
    beam_type = -1
}

if (place_meeting(x, y, object_player_combat_hitbox)) {
    rebounded = true
    rebounds += 1
    beam_type = -1
    if (instance_exists(object_player)) {
        object_player.fight = false
    }
    object_murray_boss.emit_reset_beam = false
    beam_freeze_timer = 15
    spawn_timer = 15
    prev_speed = speed * 1.3
    prev_direction = direction
    speed = 0
    //global.view = 1
    //room_speed = 15
    part_type_speed(beam_impact_part, 0, 0, 0, 0)
    part_type_colour1(beam_impact_part, make_color_rgb(135, 206, 250))
    audio_sound_pitch(sword_impact_1, random_range(0.95,1.05))
    audio_play_sound(sword_impact_1, 10, false)
    instance_create(x, y, object_hit_part)
    // Music
    audio_sound_gain(global.music, 0, 1)
    audio_stop_sound(beam_rebounded)
    audio_sound_pitch(beam_rebounded, 0.9 + rebounds/10)
    audio_play_sound(beam_rebounded, 3, 1)
}

if (rebounded) {
    if keyboard_check(vk_up) {
        if ((abs(90 - direction) &lt; (6 + rebounds)) || (direction == 90)) {
            direction = 90
        } else if (direction &lt; 90 || direction &gt; 270) { //0 - 90 270 - 360
            direction += (9 + (rebounds * 2))
        } else {
            direction -= (9 + (rebounds * 2))    
        }
    } else if keyboard_check(vk_down) {
        if ((abs(270 - direction) &lt; (6 + rebounds)) || (direction == 270)) {
            direction = 270
        } else if (direction &gt; 90 &amp;&amp; direction &lt; 270) { // 90 - 270
            direction += (9 + (rebounds * 2))
        } else {
            direction -= (9 + (rebounds * 2))    
        }
    } else if keyboard_check(vk_left) {
        if ((abs(180 - direction) &lt; (6 + rebounds)) || (direction == 180)) {
            direction = 180
        } else if (direction &gt; 0 &amp;&amp; direction &lt; 180) { // 0 - 180
            direction += (9 + (rebounds * 2))
        } else {
            direction -= (9 + (rebounds * 2))    
        }
    } else if keyboard_check(vk_right) {
        if ((0 + direction &lt; (6 + rebounds)) || ((0 - direction + 360) &lt; (6 + rebounds))  || (direction == 0)) {
            direction = 0
        } else if (direction &gt; 180) { // &lt; 180
            direction += (9 + (rebounds * 2))
        } else {
            direction -= (9 + (rebounds * 2))    
        }
    }
}

if (place_meeting(x, y, object_murray_boss)) &amp;&amp; (rebounded) {
    rebounded = false
    rebounds += 1
    if (instance_exists(object_player)) {
        object_player.fight = true
    }
    beam_freeze_timer = 15
    spawn_timer = 15
    prev_speed = speed * 1.3
    prev_direction = direction
    speed = 0
    part_type_speed(beam_impact_part, 0, 0, 0, 0)
    part_type_colour1(beam_impact_part, c_red)
    audio_sound_pitch(sword_impact_1, random_range(0.7,0.8))
    audio_play_sound(sword_impact_1, 10, false)
    instance_create(x, y, object_hit_part)
    // Music
    audio_stop_sound(beam_rebounded)
    audio_sound_pitch(beam_rebounded, 0.9 + rebounds/10)
    audio_play_sound(beam_rebounded, 3, 1)
}

// Collision

collision = false
if (instance_exists(object_player)) {
    if ((place_meeting(x, y, object_player)) &amp;&amp; !rebounded) {
        collision = true
    }
}
if (place_meeting(x, y, object_solid) &amp;&amp; (spawn_timer == -1)) {
    collision = true
}
if (collision) {
    if (rebounds &gt; 0) {
        if (instance_exists(object_player)) {
            object_player.fight = true
        }
        // Reset music
        audio_stop_sound(beam_rebounded)
        audio_sound_gain(global.music, 1, 1000)
    }
    rebounded = false
    object_murray_boss.emit_reset_beam = true
    audio_play_sound(beam_explode,1,0)
    instance_destroy()
}

colliding_beam = instance_place(x, y, object_sword_beam)
if ((colliding_beam != noone) &amp;&amp; (rebounds &gt; 0)) {
    if (power_level &lt; 3) {
        power_level += 1
        power_up_part_timer = 30
        part_type_size(beam_absorb_part, 0.3 + power_level/10, 0.3 + power_level/10, 0, 0)
        audio_sound_pitch(beam_absorb, 1 + power_level/10)
        audio_play_sound(beam_absorb, 0.1, 0)  
        if (power_level == 3) {
            part_type_colour1(beam_impact_part, c_blue)
            part_type_size(beam_absorb_part, 0.8, 0.8, 0, 0)
            audio_play_sound(beam_full_power, 0.1, 0)
        }
    }
    with (colliding_beam) {
        instance_destroy()
    }
    part_type_size(beam_impact_part, 0.3 + power_level/10, 0.5 + power_level/10, 0, 0)
}

if (beam_freeze_timer == 0) {
    beam_freeze_timer = -1;
    speed = prev_speed
    direction = prev_direction + 180
    beam_part_dir = direction + 180
    //global.view = 0
    //room_speed = 30
    part_type_direction(beam_impact_part, beam_part_dir, beam_part_dir, 0, 0)
    part_type_speed(beam_impact_part, beam_part_speed, beam_part_speed, 0, 0)
} else if (beam_freeze_timer != -1) {
    beam_freeze_timer -= 1;
}

if (spawn_timer == 0) {
    spawn_timer = -1
} else if (spawn_timer != -1) {
    spawn_timer -= 1
}

if (power_up_part_timer == 0) {
    power_up_part_timer = -1
} else if (power_up_part_timer != -1) {
    power_up_part_timer -= 1
    part_emitter_region(beam_absorb_sys, beam_absorb_part_emitter, x, x, y, y, ps_shape_ellipse, ps_distr_linear)
    part_emitter_burst(beam_absorb_sys, beam_absorb_part_emitter, beam_absorb_part, 1)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
