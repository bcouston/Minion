<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite_beam</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>object_player_damage_hitbox</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Damage
player_recoil = 20
player_damage = 20
fragile = true
destroy = false

// Directional stuff based on which way boss is facing
beam_direction = object_murray_boss.jump_direction
if (beam_direction == 1) {
    boundary_x = object_boss_room_boundary_r.x
} else {boundary_x = object_boss_room_boundary_l.x}

player_x_pos = 0
player_y_pos = 0

prev_speed = speed
prev_direction = direction
rebounded = false
rebounds = 0
moved_past_player = false
keep_on_path = false
homing_on_player = false
power_level = 0

beam_part_speed = speed
beam_part_dir = direction + 180
beam_freeze_timer = -1

spawn_timer = 30
power_up_part_timer = 0
spawn_decelerate_timer = 30

beam_impact = part_system_create()
part_system_depth(beam_impact, 0)

beam_absorb_sys = part_system_create()
part_system_depth(beam_impact, 0)

// Particles

// Beam trail
beam_impact_part = part_type_create()
part_type_shape(beam_impact_part, pt_shape_sphere)
part_type_orientation(beam_impact_part, 0, 0, 0, 0, 1)
part_type_size(beam_impact_part, 0.3, 0.5, 0, 0)
part_type_speed(beam_impact_part, beam_part_speed, beam_part_speed, 0, 0)
part_type_direction(beam_impact_part, beam_part_dir, beam_part_dir, 0, 0)
part_type_life(beam_impact_part, 12, 12)
part_type_alpha3(beam_impact_part, 1, 0.9, 0.1)
part_type_colour1(beam_impact_part, c_orange)

// Beam_absorb
beam_absorb_part = part_type_create()
part_type_shape(beam_absorb_part, pt_shape_ring)
part_type_orientation(beam_absorb_part, 0, 0, 0, 0, 1)
part_type_size(beam_absorb_part, 0.3, 0.3, 0, 0)
part_type_speed(beam_absorb_part, beam_part_speed, beam_part_speed, 0, 0)
part_type_direction(beam_absorb_part, beam_part_dir, beam_part_dir, 0, 0)
part_type_life(beam_absorb_part, 9, 9)
part_type_alpha3(beam_absorb_part, 1, 0.5, 0.1)
part_type_colour1(beam_absorb_part, c_white)

beam_impact_part_emitter = part_emitter_create(beam_impact)
beam_absorb_part_emitter = part_emitter_create(beam_absorb_sys)
part_emitter_region(beam_impact, beam_impact_part_emitter, x, x, y, y, ps_shape_ellipse, ps_distr_linear)

speed = 10
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//beam_part_dir = direction + 180

image_angle = direction
part_emitter_region(beam_impact, beam_impact_part_emitter, x, x, y, y, ps_shape_ellipse, ps_distr_linear)
part_emitter_burst(beam_impact, beam_impact_part_emitter, beam_impact_part, 1)

/*if (shield_beam != -1) {
    if (shield_beam != 1) {
        part_type_shape(beam_impact_part, pt_shape_sphere)
        shield_beam = -1
    } else {
        part_type_shape(beam_impact_part, pt_shape_snow)
        shield_beam = -1    
    }
}*/

// Specific phase conditions
if (object_murray_boss.phase == 3) {
    if (rebounded) &amp;&amp; (y &lt; (object_boss_room_boundary_d.y - ((object_boss_room_boundary_d.y - object_boss_room_boundary_u.y)/3))) {
        object_murray_boss.pause_beam_emit = false
    } else if (rebounded) {
        object_murray_boss.pause_beam_emit = true      
    }
}


if (instance_exists(object_player)) {
    player_x_pos = object_player.x
    player_y_pos = object_player.y
}

// Straight forward from boss
if (beam_type == 0) {
    direction = 0
    if (beam_direction == 1) {
        direction = 0
    } else {
        direction = 180
    }
    beam_type = -1
// Homing curve
} else if (beam_type == 1) { 
    new_x = x - (player_x_pos - ((player_x_pos - object_murray_boss.x)/2))
    gradient = -0.004 * new_x
    new_angle = arctan2(gradient,1) * (180/pi)
    if (beam_direction == 1) {
        direction = new_angle
    } else {
        direction = new_angle + 180
    }
// Jump height s beam
} else if (beam_type == 2) {
    new_x = x - (object_murray_boss.start_pos_x + (beam_direction * 30))
    new_y = 6 / (1 + exp(-0.1 * new_x))
    gradient = beam_direction * ((new_y / 6) * (6 - new_y))
    new_angle = arctan2(gradient,1) * (180/pi)
    if (beam_direction == 1) {
        direction = new_angle
    } else {
        direction = new_angle + 180
    }
// Death from above
} else if (beam_type == 3) {
    beam_beyond_halfway = ((beam_direction * x) &gt; (beam_direction * (object_boss_room_boundary_r.x - ((object_boss_room_boundary_r.x - object_boss_room_boundary_l.x)/2))))
    if ((distance_to_point(player_x_pos, player_y_pos) &lt;= 80) &amp;&amp; beam_beyond_halfway) || keep_on_path {
        keep_on_path = true
    } else if !beam_beyond_halfway &amp;&amp; !homing_on_player {
        if (beam_direction == 1) {
            direction = 30
        } else {
            direction = 150
        }
        //show_message(direction)
    } else {   
        homing_on_player = true
        direction = point_direction(x,y,player_x_pos,player_y_pos);       
    }
// S shaped backstab
} else if (beam_type == 4) {
    if (distance_to_point(player_x_pos, player_y_pos) &lt;= 45 &amp;&amp; ((beam_direction * x) &gt; (beam_direction * (object_murray_boss.start_pos_x + (beam_direction * 300))))) || keep_on_path {
        keep_on_path = true
    // Else follow sigmoid function curve
    } else if (((beam_direction * x) &lt; (beam_direction * (player_x_pos + (beam_direction * 90)))) &amp;&amp; !moved_past_player) &amp;&amp; (distance_to_point(boundary_x, y) &gt; 40) {
        new_x = x - (object_murray_boss.start_pos_x + (beam_direction * 250))
        new_y = 20 / (1 + exp(-0.1 * new_x))
        gradient = beam_direction * ((new_y / 20) * (20 - new_y))
        new_angle = arctan2(gradient,1) * (180/pi)
        if (beam_direction == 1) {
            direction = new_angle
        } else {
            direction = new_angle + 180
        }
    } else if (y &lt; (player_y_pos - 50)) {
        moved_past_player = true
        direction = point_direction(x,y,x,player_y_pos - 50);
    } else {
        direction = point_direction(x,y,player_x_pos,player_y_pos);   
    }
}

if (place_meeting(x, y, object_player_combat_hitbox)) {
    rebounded = true
    rebounds += 1
    beam_type = -1
    keep_on_path = false
    moved_past_player = false
    homing_on_player = false
    if (instance_exists(object_player)) {
        object_player.fight = false
    }
    player_damage = 0
    object_murray_boss.pause_jump_timer = true
    beam_freeze_timer = 15
    spawn_timer = 20
    prev_speed = speed
    prev_direction = direction
    speed = 0
    //global.view = 1
    //room_speed = 15
    part_type_speed(beam_impact_part, 0, 0, 0, 0)
    part_type_colour1(beam_impact_part, make_color_rgb(135, 206, 250))
    audio_sound_pitch(sword_impact_1, random_range(0.95,1.05))
    audio_play_sound(sword_impact_1, 10, false)
    instance_create(x, y, object_hit_part)
    // Music
    audio_sound_gain(global.music, 0, 1)
    audio_stop_sound(beam_rebounded)
    audio_sound_pitch(beam_rebounded, 0.9 + rebounds/10)
    audio_play_sound(beam_rebounded, 3, 1)
}

if (rebounded &amp;&amp; instance_exists(object_player) &amp;&amp; object_player.hurt_timer == -1) {
    if keyboard_check(vk_up) {
        if ((abs(90 - direction) &lt; (6 + rebounds)) || (direction == 90)) {
            direction = 90
        } else if (direction &lt; 90 || direction &gt; 270) { //0 - 90 270 - 360
            direction += (9 + (rebounds * 2))
        } else {
            direction -= (9 + (rebounds * 2))    
        }
    } else if keyboard_check(vk_down) {
        if ((abs(270 - direction) &lt; (6 + rebounds)) || (direction == 270)) {
            direction = 270
        } else if (direction &gt; 90 &amp;&amp; direction &lt; 270) { // 90 - 270
            direction += (9 + (rebounds * 2))
        } else {
            direction -= (9 + (rebounds * 2))    
        }
    } else if keyboard_check(vk_left) {
        if ((abs(180 - direction) &lt; (6 + rebounds)) || (direction == 180)) {
            direction = 180
        } else if (direction &gt; 0 &amp;&amp; direction &lt; 180) { // 0 - 180
            direction += (9 + (rebounds * 2))
        } else {
            direction -= (9 + (rebounds * 2))    
        }
    } else if keyboard_check(vk_right) {
        if ((0 + direction &lt; (6 + rebounds)) || ((0 - direction + 360) &lt; (6 + rebounds))  || (direction == 0)) {
            direction = 0
        } else if (direction &gt; 180) { // &lt; 180
            direction += (9 + (rebounds * 2))
        } else {
            direction -= (9 + (rebounds * 2))    
        }
    }
}

if (place_meeting(x, y, object_murray_boss)) &amp;&amp; (rebounded) {
    if (instance_exists(object_player)) {
        object_player.fight = true
    }
    if (rebounds &gt; object_murray_boss.max_rebounds) {
        audio_play_sound(beam_damage,1.5,0)
        audio_play_sound(beam_explode,1,0)
        audio_stop_sound(beam_rebounded)
        audio_sound_gain(global.music, 1, 1000)
        object_murray_boss.boss_health -= 20
        object_murray_boss.phase += 1
        object_murray_boss.pause_jump_timer = false
        instance_destroy()
    } else {
        rebounded = false
        rebounds += 1
        player_damage = 20
        beam_freeze_timer = 15
        spawn_timer = 30
        prev_speed = speed
        prev_direction = direction
        speed = 0
        part_type_speed(beam_impact_part, 0, 0, 0, 0)
        part_type_colour1(beam_impact_part, c_red)
        audio_sound_pitch(sword_impact_1, random_range(0.7,0.8))
        audio_play_sound(sword_impact_1, 10, false)
        instance_create(x, y, object_hit_part)
        // Music
        audio_stop_sound(beam_rebounded)
        audio_sound_pitch(beam_rebounded, 0.9 + rebounds/10)
        audio_play_sound(beam_rebounded, 3, 1)
    }
    object_murray_boss.pause_beam_emit = false
}

// Collision

collision = false
if (place_meeting(x, y, object_solid) &amp;&amp; (spawn_timer == -1)) {
    collision = true
}
if (destroy) {
    collision = true
}
if (collision) {
    if (rebounds &gt; 0) {
        if (instance_exists(object_player)) {
            object_player.fight = true
        }
        object_murray_boss.pause_jump_timer = false
        //if (rebounded) {
        show_message("collision")
        object_murray_boss.pause_beam_emit = false
        //}
        // Reset music
        audio_stop_sound(beam_rebounded)
        audio_sound_gain(global.music, 1, 1000)
    }
    rebounded = false
    audio_play_sound(beam_explode,1,0)
    instance_destroy()
}

colliding_beam = instance_place(x, y, object_sword_beam)
if ((colliding_beam != noone) &amp;&amp; (rebounds &gt; 0)) {
    if (power_level &lt; 3) {
        power_level += 1
        power_up_part_timer = 30
        part_type_size(beam_absorb_part, 0.3 + power_level/10, 0.3 + power_level/10, 0, 0)
        audio_sound_pitch(beam_absorb, 1 + power_level/10)
        audio_play_sound(beam_absorb, 0.1, 0)  
        if (power_level == 3) {
            part_type_colour1(beam_impact_part, c_blue)
            part_type_size(beam_absorb_part, 0.8, 0.8, 0, 0)
            audio_play_sound(beam_full_power, 0.1, 0)
        }
    }
    with (colliding_beam) {
        instance_destroy()
    }
    part_type_size(beam_impact_part, 0.3 + power_level/10, 0.5 + power_level/10, 0, 0)
}

if (beam_freeze_timer == 0) {
    beam_freeze_timer = -1;
    //beam_direction = beam_direction * -1  
    if (!rebounded) {
        switch (object_murray_boss.phase) {
            case 1: beam_type = 0; break;//irandom(2) + 1
            case 2:
                if (rebounds == 2) {beam_type = 0;}
                else {beam_type = 1} break;//irandom(2) + 1
            case 3: {beam_type = 3} break;//irandom(2) + 1
        }
    }  
    //} else {
    beam_direction = object_murray_boss.jump_direction
    direction = prev_direction + 180  
    //}
    speed = prev_speed * 1.1
    //global.view = 0
    //room_speed = 30
    part_type_direction(beam_impact_part, beam_part_dir, beam_part_dir, 0, 0)
    part_type_speed(beam_impact_part, beam_part_speed, beam_part_speed, 0, 0)
    audio_sound_pitch(beam_crackle, 0.9 + rebounds/10)
    audio_play_sound(beam_crackle, 3, 0)
} else if (beam_freeze_timer != -1) {
    beam_freeze_timer -= 1;
}

if (spawn_timer == 0) {
    spawn_timer = -1
} else if (spawn_timer != -1) {
    spawn_timer -= 1
}

if (spawn_decelerate_timer == 0) {
    spawn_decelerate_timer = -1
} else if (spawn_decelerate_timer != -1) {
    spawn_decelerate_timer -= 1
    speed -= (10 - 6) / 30
}

if (power_up_part_timer == 0) {
    power_up_part_timer = -1
} else if (power_up_part_timer != -1) {
    power_up_part_timer -= 1
    part_emitter_region(beam_absorb_sys, beam_absorb_part_emitter, x, x, y, y, ps_shape_ellipse, ps_distr_linear)
    part_emitter_burst(beam_absorb_sys, beam_absorb_part_emitter, beam_absorb_part, 1)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
